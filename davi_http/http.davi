package davi_http;

// OOP HTTP client using curl.* builtins. Use default options or pass per-request opts.
class HttpClient {
  public baseUrl = "";
  public timeout = 0;
  public auth = {};
  public headers = {};
  public insecureSkipVerify = false;
  public noRedirect = false;

  function init(a1) {
    if (a1 != nil) {
      if (type(a1) == "str") {
        this.baseUrl = a1;
      } else {
        if (isset(a1["baseUrl"])) { this.baseUrl = str(a1["baseUrl"]); }
        if (isset(a1["timeout"])) { this.timeout = int(a1["timeout"]); }
        if (isset(a1["auth"])) { this.auth = a1["auth"]; }
        if (isset(a1["headers"])) { this.headers = a1["headers"]; }
        if (isset(a1["insecureSkipVerify"])) { this.insecureSkipVerify = a1["insecureSkipVerify"]; }
        if (isset(a1["noRedirect"])) { this.noRedirect = a1["noRedirect"]; }
      }
    }
  }

  function _url(path) {
    if (this.baseUrl == "" or path == nil or str(path) == "") { return str(path); }
    base = this.baseUrl;
    if (string.hasSuffix(base, "/")) { base = string.trimSuffix(base, "/"); }
    p = str(path);
    if (string.hasPrefix(p, "/")) { p = string.trimPrefix(p, "/"); }
    return base . "/" . p;
  }

  function _opts(overrides) {
    o = {};
    kT = "timeout";
    kA = "auth";
    kI = "insecureSkipVerify";
    kN = "noRedirect";
    o[kT] = this.timeout;
    o[kA] = this.auth;
    o[kI] = this.insecureSkipVerify;
    o[kN] = this.noRedirect;
    for (k, v in this.headers) { o[k] = v; }
    if (overrides != nil) {
      for (k, v in overrides) { o[k] = v; }
    }
    return o;
  }

  function _headerList(opts) {
    list = [];
    for (k, v in opts) {
      if (k != "timeout" and k != "auth" and k != "insecureSkipVerify" and k != "noRedirect") {
        append(list, k . ": " . str(v));
      }
    }
    return list;
  }

  function _do(method, url, body, opts) {
    u = this._url(url);
    timeoutVal = this.timeout;
    authVal = this.auth;
    insecureVal = this.insecureSkipVerify;
    noRedirectVal = this.noRedirect;
    headerOverrides = {};
    if (opts != nil) {
      kT = "timeout";
      kA = "auth";
      kI = "insecureSkipVerify";
      kN = "noRedirect";
      if (isset(opts[kT])) { timeoutVal = int(opts[kT]); }
      if (isset(opts[kA])) { authVal = opts[kA]; }
      if (isset(opts[kI])) { insecureVal = opts[kI]; }
      if (isset(opts[kN])) { noRedirectVal = opts[kN]; }
      for (k, v in opts) {
        if (k != "timeout" and k != "auth" and k != "insecureSkipVerify" and k != "noRedirect") {
          headerOverrides[k] = v;
        }
      }
    }
    o = {};
    kT = "timeout";
    kA = "auth";
    kI = "insecureSkipVerify";
    kN = "noRedirect";
    o[kT] = timeoutVal;
    o[kA] = authVal;
    o[kI] = insecureVal;
    o[kN] = noRedirectVal;
    for (k, v in this.headers) { o[k] = v; }
    for (k, v in headerOverrides) { o[k] = v; }
    h = curl.easy();
    curl.setopt(h, "URL", u);
    if (int(timeoutVal) > 0) { curl.setopt(h, "TIMEOUT", timeoutVal); }
    if (insecureVal) { curl.setopt(h, "SSL_VERIFYPEER", false); }
    if (noRedirectVal) { curl.setopt(h, "FOLLOWLOCATION", false); }
    kUser = "user";
    kPass = "pass";
    if (isset(authVal) and isset(authVal[kUser]) and isset(authVal[kPass])) {
      curl.setopt(h, "USERPWD", str(authVal[kUser]) . ":" . str(authVal[kPass]));
    }
    hl = this._headerList(o);
    if (array.len(hl) > 0) { curl.setopt(h, "HTTPHEADER", hl); }
    if (method == "HEAD") {
      curl.setopt(h, "NOBODY", true);
    } else if (method != "GET") {
      curl.setopt(h, "CUSTOMREQUEST", method);
      if (body != nil and str(body) != "") {
        curl.setopt(h, "POST", true);
        curl.setopt(h, "POSTFIELDS", str(body));
      }
    }
    res = curl.perform(h);
    curl.close(h);
    return res;
  }

  function get(url, opts) {
    return this._do("GET", url, nil, opts);
  }

  function head(url, opts) {
    return this._do("HEAD", url, nil, opts);
  }

  function post(url, body, opts) {
    return this._do("POST", url, body, opts);
  }

  function request(method, url, body, opts) {
    return this._do(method, url, body, opts);
  }

  function postForm(url, body, opts) {
    return this.post(url, body, opts);
  }
}
